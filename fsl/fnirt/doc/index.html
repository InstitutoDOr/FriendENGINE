<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<link rel="stylesheet" type="text/css" href="../fsl.css">
<title>FSL</title>
</head>

<body background="../images/fsl-bg.jpg">

<hr>
<table border=0, width="100%">
<tr>
<td align=center>
<h1>FNIRT - FMRIB's Non-linear Image Registration Tool</h1>
FNIRT v1.0&beta - User Guide
</td>
<td align=right>
<a href="../index.html"><img border=0, src="../images/fsl-logo.jpg"></a>
</td>
</tr>
</table>
<hr>

<h2>Contents</h2>
<ul>
<li><a href="#fnirt_introduction">Introduction</a></li>
<li><a href="#fnirt_principles">Principles</a></li>
<ul>
<li><a href="#fnirt_model">Deformation model</a></li>
<li><a href="#fnirt_cost">Cost-function</a></li>
<li><a href="#fnirt_optimisation">Optimisation</a></li>
<li><a href="#fnirt_subsampling">Sub-sampling</a></li>
<li><a href="#fnirt_regularisation">Regularisation</a></li>
<li><a href="#fnirt_intensity">Intensity modulation</a></li>
<li><a href="#fnirt_diffeomorphic">Is it diffeomorphic (and what does "diffeomorphic" mean)?</a></li>
</ul>
<li><a href="#fnirt_fnirt">Software implementation</a></li>
<ul>
<li><a href="#fnirt_config_files">Configuration files</a></li>
<li><a href="#fnirt_running">Running <tt>fnirt</tt> efficiently</a></li>
<li><a href="#fnirt_understanding_subsample">Understanding sub-sampling levels</a></li>
<li><a href="#fnirt_parameters">List of paramaters</a></li>
<li><a href="#fnirt_now_what">Now what? -- applywarp</a></li>
<li><a href="#fnirt_examples">Example uses</a></li>
<li><a href="./warp_utils.html">List of tools for handling warps</a></li>
<li><a href="./combining_warps.html">Some examples of combining warps</a></li>
</ul>
</ul>

<a name="fnirt_introduction"></a><h2>Introduction</h2>
<p>
It is frequently desirable to register different brains to each other, or to register a set of brains to a common space/template. This is for example the case when one wants to pool fMRI results across several subjects at a second level or when wanting to compare fractional anisotropy (<a href="../tbss/index.html">TBSS</a>) or tissue composition (<a href="../fslvbm/index.html">FSL-VBM</a>) between groups. Registration algorithms can be divided into <i>linear</i> and <i>non-linear</i> depending on the type of deformations they permit. <a href="../flirt/index.html">FLIRT</a> is an example of a software that performs linear registration, meaning that it will translate, rotate, zoom and shear one image to match it with another. Sometimes the differences between subjects are such that the linear transform is not sufficient to achieve good registration. The local deformations permitted by a non-linear method may then do a better job.
</p>
<a name="atrophy_brains"></a><table class="image">
<tr>
<td><img border=0, width=136.5, height=163.5, src="flirted_subj1.jpg"></td>
<td><img border=0, width=136.5, height=163.5, src="flirted_subj2.jpg"></td>
<td>&nbsp</td>
<td><img border=0, width=136.5, height=163.5, src="template.jpg"></td>
<td>&nbsp</td>
<td><img border=0, width=136.5, height=163.5, src="fnirted_subj1.jpg"></td>
<td><img border=0, width=136.5, height=163.5, src="fnirted_subj2.jpg"></td>
</tr>
<tr>
<td align="center", class="caption">flirted subject #1</td>
<td align="center", class="caption">flirted subject #2</td>
<td>&nbsp</td>
<td align="center", class="caption">MNI152 T1</td>
<td>&nbsp</td>
<td align="center", class="caption">fnirted subject #1</td>
<td align="center", class="caption">fnirted subject #2</td>
</tr>
</table>
<p>
The example above demonstrates how a linear transform is unable to account for the local changes around ventricles and sulci caused by atrophy. While the non-linear model has done a reasonable job of compensating for this.
</p>

<a name="fnirt_principles"></a><h2>Principles</h2>

<ul>
<li><a href="#fnirt_model">Deformation model</a></li>
<li><a href="#fnirt_cost">Cost-function</a></li>
<li><a href="#fnirt_optimisation">Optimisation</a></li>
<li><a href="#fnirt_subsampling">Sub-sampling</a></li>
<li><a href="#fnirt_regularisation">Regularisation</a></li>
<li><a href="#fnirt_intensity">Intensity modulation</a></li>
<li><a href="#fnirt_diffeomorphic">Is it diffeomorphic (and what does "diffeomorphic" mean)?</a></li>
</ul>

<a name="fnirt_model"></a><h3>Deformation model</h3>

<p>
An affine transformation is characterised by a coordinate transform defined as
</p>
<img border=0, src="linear_transformation.png">
<p>
where <b>A</b> is a 4x4 matrix that is uniquely defined by 12 values (3 translations, 3 rotations, 3 zooms and 3 shears). This is sufficient to model overall differences in position and size between different brains. However it is often not sufficient for modelling more "local" differences such as <i>e.g.</i> enlarged ventricles or sulci. One may then instead use a non-linear transformation given by
</p>
<img border=0, src="non_linear_transformation.png">
<p>
The crucial part here are the <i>d<sub>i</sub>(x,y,z)</i>, the warp fields. These are three (one for each dimension) fields of displacements, each of which have the same size as the image one is warping towards. They are often represented as linear combinations of basis-functions, thereby reducing the number of parameters that needs to be determined. In the case of fnirt they are represented by quadratic or cubic B-splines. 
</p> 

<a name="fnirt_cost"></a><h3>Cost-function</h3>
<p>
The only cost-function presently implemented in fnirt is the "sum-of-squared differences". <i>I.e.</i> it attempts to minimize the function
</p>
<img border=0, src="simple_cost_function.png">
<p>
where <i>f</i> denotes the "reference image" (<i>e.g.</i> the MNI152-template) and <i>g</i> denotes the image we want to warp. This would potentially limit its (fnirt's) use to cases where the images <i>f</i> and <i>g</i> are very similar, as opposed to other cost-functions like <i>e.g.</i> correlation-ratio or mutual information which are less sensitive to differences in contrast. However, the sum-of-squared differences cost-function has important advantages when <a href="#fnirt_optimisation">searching</a> for the parameters that minimize its value. In addition fnirt has the option of <a href="#fnirt_intensity">modulating the intensity</a> of <i>f</i>, both globally and locally, that addresses the issue of differences in contrast.
</p>
 
<a name="fnirt_optimisation"></a><h3>Optimisation</h3>
<p>
Registration (linear or non-linear) is really a non-linear optimisation problem in that there is some function <i>O</i> that depends in a non-linear fashion on some set of parameters <b>w</b>, and we want to find the values of <b>w</b> that minimizes <i>O</i>. Methods for finding the parameters <b>w</b> come in various flavors; Some will require only the ability to calculate <i>O</i>(<b>w</b>) whereas other relies also on the first, and possibly second, derivatives with respect to <b>w</b>. Methods in the latter category can potentially have large advantages over the former in terms of executions speed, something that is especially important when there are a large number of unknown parameters.
</p>
<p>
The Gauss-Newton method falls into the second category and is an approximation to the Newton-Raphson method that is valid when the function <i>O</i> is a sum-of-squares. It provides an explicit formula for where to take the next step in the parameter space <b>w</b>.
</p>
<img border=0, src="gauss_newton_step.png">
<p>
Where <b>H</b> and &nabla<i>O</i> denotes the Hessian and the gradient of <i>O</i> respectively. This is an advantage of Gauss-Newton over many other methods that will only provide a direction in which to search for a local minima, and will potentially enable faster convergence.
</p>
<p>
Fnirt has been implemented using a Levenberg-Marquardt modification of the Gauss-Newton method and great effort has gone into an efficient calculation of <b>H</b>. 

<a name="fnirt_subsampling"></a><h3>Sub-sampling</h3>

One of the difficulties in non-linear registration is to avoid logal minima. To understand this think of a section of cortex with two sulci from two different subjects. Let us furthermore assume that due to different shape brains the two sulci are shifted along the surface of the cortex in one brain relative to the other. A reasonable "solution" to this problem would be to translate the two sulci until they match up. Another solution would be to simply flatten out the existing sulci, and create two new ones in the correct position. Because of the considerable freedom in the transformations with a non-linear registrations this is something that could actually happen.

One way of forcing the warps towards being more "reasonable" in that sense is through <a href="#fnirt_regularisation">regularisation</a>. Another is "sub-sampling" or "multi-resolution" registration. That means that one starts out by sub-sampling, <i>i.e.</i> degrading the resolution of the images, by some factor and then register the resulting low-resolution images together. This ensures that gross structures in the images are registered first. The warp-fields from this first registration are now used as intial values in a second registration, this time with less sub-sampling and so forth until finally one is using the full resolution of the images (<i>i.e.</i> no sub-sampling at all).

<a name="fnirt_regularisation"></a><h3>Regularisation</h3>
<p>
All non-linear registration is a compromise between minimising the cost-function, <i>i.e.</i> between making the images look as similar as possible, and making the warps/displacements "reasonable". This is based on a notion that some warps are more reasonable, or probable, than others. We typicall find a smoother warp more likely than one that is very sharp. In addition there is the notion of one-to-one and onto. With one-to-one we mean that there can only be one point in the original space mapping into any given point in the transformed space and by onto we mean that there cannot be any points in the transformed space to which there is no mapping. 
</p>
<p>
This compromise is formalised by some regularising function, typically with concepts borrowed from mechanics. Examples of regularising functions are "membrane energy" and "bending energy". These are functions of the warps themselves, the images doesn't enter into it, that have a high value for sharp warps and a small value for smooth warps.
</p>
<p>
Hence the cost-function that we really minimise is
</p>
<a name="cost_function_with_regularisation"></a><img border=0, src="cost_function_with_regularisation.png">
<p>
where <i>&epsilon</i> is the regularisation function and &lambda is a "fudge factor" that determines the relative balance between how "similar" the images get and how "smooth" we want the warps. 
</p>
<p>Below is an example of warping a subject (with some atrophy) to the MNI152 template with "medium" regularisation (&lambda=30 with the <a href="#fnirt_ssqlambda"><tt>ssqlambda</tt></a> option set) and with "little" regularisation (&lambda=8 with the <a href="#fnirt_ssqlambda"><tt>ssqlambda</tt></a> option set) 
</p>
<a name="regularisation_brains"></a><table class="image">
<tr>
<td><img border=0, width=136.5, height=163.5, src="flirted_subj2.jpg"></td>
<td>&nbsp</td>
<td><img border=0, width=136.5, height=163.5, src="smooth_warps.jpg"></td>
<td><img border=0, width=136.5, height=163.5, src="fnirted_subj2.jpg"></td>
<td>&nbsp</td>
<td><img border=0, width=136.5, height=163.5, src="template.jpg"></td>
<td>&nbsp</td>
<td><img border=0, width=136.5, height=163.5, src="fnirted_subj2_less_reg.jpg"></td>
<td><img border=0, width=136.5, height=163.5, src="sharp_warps.jpg"></td>
</tr>
<tr>
<td align="center", class="caption">Linearly<br>registered<br>image</td>
<td>&nbsp</td>
<td align="center", class="caption">Warps with<br>medium<br>regularisation</td>
<td align="center", class="caption">Warped image<br>with medium<br>regularisation</td>
<td>&nbsp</td>
<td align="center", class="caption">MNI152 T1</td>
<td>&nbsp</td>
<td align="center", class="caption">Warped image<br>with little<br>regularisation</td>
<td align="center", class="caption">Warps<br>with little<br>regularisation</td>
</tr>
</table>
<p>
In the images abov it can be seen that with the larger value for &lambda (warp and image on the left) the warps are smoother and the warped image is, possibly, a little less similar to the template. With the smaller value for &lambda (warp and image on the right) the image is slightly more similar to the template, in particular the ventricles and the left Sylvian fissure, but at the expense of sharper warps. For this particular data set there are more than ten voxels (in the whole volume) where the one-to-one condition has been violated when using the lower value for &lambda, so clearly the larger value is more appropriate in this case.
</p>
<p>
We refer to &lambda as a "fudge factor", and the reason for that is that we have no principled way of deriving an appropriate value for it. It will have to be determined empirically for each "category" of images. If one for example wants to register structural T1-weighted images with reasonable contrast and signal-to-noise one determines, once and for all, a suitable value for &lambda and uses that for subsequent studies. There are some examples of "appropriate" values in the <a href="#fnirt_examples">"Example uses"</a> section. 
</p> 
<a name="fnirt_intensity"></a><h3>Intensity modulation</h3>
<p>
The sum-of-squared differences cost function assumes that the images <i>f</i> and <i>g</i> are identical save for some differences in shape, and can get its knickers in a twist when that is not the case.
An example of this is when one of the images is affected by a bias-field while the other is not.
</p>
<table class="image">
<tr>
<td><img border=0, width=136.5, height=163.5, src="flirted_bias.jpg"></td>
<td>&nbsp</td>
<td><img border=0, width=136.5, height=163.5, src="template.jpg"></td>
<td>&nbsp</td>
<td><img border=0, width=136.5, height=163.5, src="gl_obj_bias.jpg"></td>
</tr>
<tr>
<td align="center", class="caption">flirted image</td>
<td>&nbsp</td>
<td align="center", class="caption">MNI152 T1</td>
<td>&nbsp</td>
<td align="center", class="caption">fnirted image</td>
</tr>
</table>
<p>
We can see from the images above that for this subject the linear registration (flirt) did a good job. We can also see that there is a considerable intensity gradient (bias-field) in the anterior-posterior direction of the image. When looking at the fnirted image we see how it (fnirt) has "tried to correct" for this by shrinking the white matter in the posterior part of the brain, thereby reducing the intensity. Conversly it has shrunk the gray matter in the frontal parts, increasing the intensity there.
</p> 
<p>
In fnirt this can be addressed using the various intensity modulation options that are available. For the example above the "local linear" option would be suitable. It is implemented by altering the cost-function to
</p>
<img border=0, src="cost_function_with_bias.png">
<p>
where <i>b</i> is now a bias-field that is explicitly modelled as part of the registration and where the parameters <b><i>&beta</i></b> are estimated along with <b>w</b> Applying this model to the example above we obtain
</p>
<table class="image">
<tr>
<td><img border=0, width=136.5, height=163.5, src="flirted_bias.jpg"></td>
<td>&nbsp</td>
<td><img border=0, width=136.5, height=163.5, src="template.jpg"></td>
<td>&nbsp</td>
<td><img border=0, width=136.5, height=163.5, src="obj_bias.jpg"></td>
<td><img border=0, width=136.5, height=163.5, src="bias_field.jpg"></td>
</tr>
<tr>
<td align="center", class="caption">flirted image</td>
<td>&nbsp</td>
<td align="center", class="caption">MNI152 T1</td>
<td>&nbsp</td>
<td align="center", class="caption">fnirted image</td>
<td align="center", class="caption">bias-field</td>
</tr>
</table>
<p>
where we can now see that when explicitly modelling the bias-field the "superfluous" warps have dissapeared. We can also see that even in this case, where the linear registration has done a very good job, there are potential gains from non-linear registration.
</p>

<a name="fnirt_diffeomorphic"></a><h3>Is it diffeomorphic (and what does "diffeomorphic" mean)?</h3>
<p>
 A diffeomorphic mapping from a space <i>U</i> to a space <i>V</i> is one which has exactly one position in <i>V</i> for each position in <i>U</i>, which also means that it is invertible and that the Jacobian of the mapping is greater than zero at each location. This is clearly a desirable property, and one which people try to achieve in non-linear registration. In recent years it has become popular to use algorithms where diffeomorphism is guaranteed by construction. To understand this we need to look at how the warps are constructed from a series of iterations. In our (oldfashioned) case the displacement field is constructed as the sum of the updates calculated at each iteration.
</p>
<img border=0, src="sum_of_displacements.png">
<p>
This means that even if each and every update is diffeomorphic in itself, the sum may not neccessarily be. There are algorithms that will instead construct the displacement field from the updates as
</p>
<img border=0, src="combination_of_displacements.png">
<p>
<i>i.e.</i> they are warping the warps rather than adding them. In this latter case one can guarantee that <b>d</b> is diffeomorphic as long as each of the <b>d</b><sub>i</sub> are diffeomorphic. This means that one can use heavy regularisation (big &lambda) when calculating each update, thereby ensuring diffeomorphism for each step, and then perform many updates (iterations) thereby still accomodating large displacements. 
</p>
<p>
<tt>fnirt</tt> is <b>not</b> diffeomorphic by construction, <i>i.e.</i> it sums the updates. Hence after each update (iteration) there is a risk that the field is no longer diffeomorphic. Therefore <tt>fnirt</tt> uses a different "trick" which means that after each sub-sampling level it checks for non-diffeomorphic fields (by searching for <=0 Jacobians) and if it finds any it will project the field onto the closest diffeomorphic field. 
</p>
<p>
This is, perhaps, less elegant then ensuring diffeomorphism by construction, but also has its own advantages. A method that guarantees dieffeomorphism by construction guarantees <b>only</b> that. The Jacobians can in principle become infinitely close to zero which can, depending on the reason for the registration, be a problem. In contrast <tt>fnirt</tt> has the ability to project the warp onto any manifold consisting of mappings with Jacobians within a specified range. By for example setting <a href="#fnirt_jacrange"><tt>--jacrange</a>=0.2,5</tt> one specifies that one wants to find the "best" warps of all those for which there are no local contractions/expansions of volume greater than 5.
 
<a name="fnirt_fnirt"></a><h2>Software implementation</h2>

<ul>
<li><a href="#fnirt_config_files">Configuration files</a></li>
<li><a href="#fnirt_running">Running <tt>fnirt</tt> efficiently</a></li>
<li><a href="#fnirt_understanding_subsample">Understanding sub-sampling levels</a></li>
<li><a href="#fnirt_parameters">List of paramaters</a></li>
<li><a href="#fnirt_now_what">Now what? -- applywarp</a></li>
<li><a href="#fnirt_examples">Example uses</a></li>
</ul>

<p>
Fnirt is a command line program that is run by typing <tt>fnirt</tt> followed by some set of parameters. The minimum you need to type is
</p>
<p>
<tt>fnirt --ref=target_image --in=input_image</tt> 
</p>
<p>
but it is not very likely it will do you any good. Fnirt has a large set of parameters that determine what is done, and how it is done. Without a knowledge of these parameters you will not get the best results that you can. These parameters are described below, but it should be said that there are many of them, and to complicate things further they are linked such that the value of one parameter will determine what is the optimal value to use for another parameter. Hence, the command line options for fnirt offers a lot of flexibility but are difficult to use unless one is an expert on non-linear registration. We therefore offer the option of using configuration files that hides the complexity of fnirt and we strongly encourage using these rather than specifying command line options oneself.
</p>

<a name="fnirt_config_files"></a><h3>Configuration files</h3>

<p>
A configuration file is a text file containing some or all of the parameters that can be specified for <tt>fnirt</tt>. The name of the file should be passed as argument to the <tt>--config</tt> parameter. It should be an ascii-file with one row for each parameter, and where comments (ignored by <tt>fnirt</tt>) are preceeded by a #. A very simple (and silly) config file named <tt>my_silly_file.cnf</tt> could look like<br><br>
<tt># I want to use membrane energy for regularisation</tt><br>
<tt>--regmod=membrane_energy</tt><br><br>
It becomes more useful when it specifes all or most parameters with values suited for ones particular application.
</p> 
<p>
When a parameter is specified both in the config-file and on the command line the value on the command line takes precedence. For example with the example above we could run <tt>fnirt</tt> with<br><br>
<tt>fnirt --in=my_brain --ref=MNI152_T1_2mm --config=my_silly_file --regmod=bending_energy</tt><br><br>
and the <tt>--regmod=bending_energy</tt> on the command line will take precedence over the specification in <tt>my_silly_file</tt>.
</p>
<p>
When you specify <tt>--config=my_file</tt>, <i>i.e.</i> without explicit path or extension, <tt>fnirt</tt> will search for <tt>./my_file</tt>, <tt>./my_file.cnf</tt>, <tt>${FSLDIR}/etc/flirtsch/my_file</tt> and <tt>${FSLDIR}/etc/flirtsch/my_file.cnf</tt> in that order and use the first one that is found.
</p>
<p> 
As part of the <tt>fnirt</tt> distribution we supply two predefined config files: <tt>T1_2_MNI152_2mm.cnf</tt> and <tt>FA_2_FMRIB58_1mm.cnf</tt>. These contain parameters that have been found to be useful for registering a good quality T1-weighted 3D acquisition to the MNI152 template and for registering a good quality FA image to the FMRIB58 template. Together with the override facility this is probably the starting (an quite possible finishing) point for most users. Let us say for example that you want to register a T1 scan to the MNI152 template, but that you want to push warp-resolution a little beyond that given in <tt>T1_2_MNI152_2mm.cnf</tt> (10mm isotropic). You may then <i>e.g.</i> run <tt>fnirt</tt> with<br><br>
<tt>fnirt --in=my_brain --config=T1_2_MNI152_2mm --warpres=6,6,6</tt><br> 
</p>
<p>
As our experience with <tt>fnirt</tt> increases and we start using it for more applications we will supply more configuration files. Meanwhile if you have an application for which neither of the predefined config files is appropriate you may want to read about the individual parameters below and write your own file. We would then recommend to start with one of the predefined files (that which seems more appropriate given your application) and gradually change it to suit your application. Alternatively if your application is of sufficient general interest you may contact us and we can together devise a file for that application.
</p>

<a name="fnirt_running"></a><h3>Running <tt>fnirt</tt> efficiently</h3>

<p>
This paragraph contains some general advice that is useful to ensure that <tt>fnirt</tt> is run in an "optimal" manner. <tt>fnirt</tt> is designed to be a "medium resolution" non-linear registration method. Hence it is intended to be used with a warp-resolution of ~10mm. If/when attempting to go much below that (<i>i.e.</i> below ~5mm) one starts to pay a high price both in terms of working memory and execution time. In general this is not a big problem since a 10mm warp-resolution is typically sufficient to register two brains. 
</p>
<p>
Another factor that greatly affects execution time and memory requirements is the resolution and the field-of-view (FOV) of the <tt>--ref</tt> image respectively. Let us say one wants for example to register one T1-scan to another. Tpical scan parameters may then be <i>e.g.</i> a 208x256x192 matrix-size with a 1x1x1mm resolution. With that FOV (208x256x192mm) there are typically thick slabs of non-brain in all directions and it may be cropped extensively (using the <tt>fslroi</tt> command) without loss of any brain. If one is <i>e.g.</i> able to crop it down to a 146x194x130 matrix (numbers taken from a specific example) one will have reduced both execution time and memory requirements by 60%.
</p>
<p> 
If one additionaly specifies a subsampling of 2 at the lowest level (<i>e.g.</i> <tt>--subsamp=8,4,2,2</tt>) there is a further reduction of execution time by a factor of eight. This implies that the full resolution of the images is never used for estimation of the warps, but that makes very little difference when using a warp-resolution of 10mm. When/if using subsampling of 2 the subsampled voxels have a size of 2x2x2mm which means that each spline-function has a support of 5832 voxels which is typically more than sufficient. If one uses the full resolution the support is a staggering 54872 voxels which is unneccessarily large and "wastes" execution time.  
</p>
<p>
It should also be realized that the level of subsampling that is used when estimating the warps does not affect the resolution of the final warp-field. It will still produce a field with the full resolution of the <tt>--ref</tt> volume and the registered volume will have the full resolution of the <tt>--ref</tt> volume. An example of a config file that uses this "trick" is <tt>FA_2_FMRIB58_1mm.cnf</tt>, which is used to register an FA-volume to the FMRIB 1mm (overkill) FA template.
</p>  
<p>
Other parameters that has an effect on efficiency include <a href="#fnirt_splineorder"><tt>--splineorder</tt></a> and <a href="#fnirt_numprec"><tt>--numprec</tt></a>. 
</p>

<a name="fnirt_understanding_subsample"></a><h3>Understanding sub-sampling levels</h3>

<p>
It is important to understand the concept of different sub-sampling levels and how that affects how one can/need to specify the different paramaters of <tt>fnirt</tt>. As described <a href="#fnirt_subsampling">above</a> in the theory section an execution of <tt>fnirt</tt> is really several consecutive registrations with increasing use of high frequency information. An example of a subsampling scheme might be <tt>--subsamp=4,2,1,1</tt> which specifies that four consecutive registrations should be performed, the first with the <tt>--ref</tt> volume sub-sampled by a factor 4, the second by a factor 2 and the two final registrations at full resolution. Given this there are some parameters that it makes sense to define "once and for all" and use for all four registration. An example of such a parameter is <tt>--regmod</tt> which specifies what regularisation model to use ("membrane energy" or "bending energy"). 
</p>
<p>
For other parameters it makes more sense to specify a separate value for each sub-sampling level. An example of such a parameter is <tt>--lambda</tt> which could for subsampling scheme above be set to <i>e.g.</i> <tt>--lambda=200,75,40,20</tt>. What this means is that we are using a larger relative weighting of the regularisation term, <i>i.e.</i> we are forcing the warps to be smoother, for the registrations performed at lower resolution (larger sub-sampling). Note also how, in this example, at the final resolution we perform two registrations with decreasing regularisation.
</p>
<p>
Hence the parameters for <tt>fnirt</tt> are divided into those that are defined "once and for all" and those that can/should be defined once for each sub-sampling level. That means that there must be a complete correspondence between the parameters in the latter category. It is for example correct to specify 
</p>
<tt>fnirt ... --subsamp=4,2,1,1 --lambda=200,75,40,20 ...</tt>
<p>
but <b>not</b> correct to specify
</p>
<tt>fnirt ... --subsamp=4,2,1 --lambda=200,75,40,20 ...</tt>
<p>
The exception to this is that it is correct to specify a single value for parameters that can/should be defined once for each level of sub-sampling. An example of that would be
</p>
<tt>fnirt ... --refmask=my_mask --subsamp=4,2,1,1 --applyrefmask=1 ...</tt>
<p>
which is equivalent to
</p>
<tt>fnirt ... --refmask=my_mask --subsamp=4,2,1,1 --applyrefmask=1,1,1,1 ...</tt>
<p>
and implies that masking should be performed at each of the four registrations.

<a name="fnirt_parameters"></a><h3>List of parameters</h3>
<ul>
<li>Parameters that specify input files</li>
<dl>
<dt><tt>--ref=filname</tt></dt>
<dd>Name of a file that defines the target space. <i>E.g.</i> MNI152_T1_2mm.nii.</dd>
<dt><tt>--in=filename</tt></dt>
<dd>Name of file with images you want to register. <i>E.g.</i> my_brain.nii</dd>
<dt><tt><a href="#fnirt_config_files">--config</a>=config_file</tt></dt>
<dd>Name of text-file with parameter settings. If you read nothing else, <a href="#fnirt_config_files">read this</a>.</dd>
<dt><tt><a href="#fnirt_aff">--aff</a>=mat_fname</tt></dt>
<dd>Name of text-file with affine starting guess. Typically the output from flirt.</dd>
<dt><tt><a href="#fnirt_inwarp">--inwarp</a>=coef/field_fname</tt></dt>
<dd>Name of coefficient/field file with non-linear starting guess. Typically the output from previous run of fnirt.</dd>
<dt><tt><a href="#fnirt_intin">--intin</a>=fname of file with global/local intensity mapping</tt></dt>
<dd>Name of file describing the intensity mapping. Typically the output from a previous run of fnirt.</dd>
<dt><tt><a href="#fnirt_refmask">--refmask</a>=filename</tt></dt>
<dd>Name of file with binary mask that determines interesting FOV. <i>E.g.</i> MNI152_T1_2mm_brain_mask_dil.nii</dd>
<dt><tt><a href="#fnirt_inmask">--inmask</a>=filename</tt></dt>
<dd>Name of file with binary mask that determine interesting FOV. <i>E.g.</i> my_mask.nii</dd>
</dl>
<br>
<li>Parameters specifying names of output-files</li>
<dl>
<dt><tt><a href="#fnirt_cout">--cout</a>=filename</tt></dt>
<dd>Name of output-file containing the coefficients that determine the warp-field.</dd>
<dt><tt><a href="#fnirt_iout">--iout</a>=filename</tt></dt>
<dd>Name of output-file containing the <tt>--in</tt> image after it has been warped to the <tt>--ref</tt> image.</dd>
<dt><tt><a href="#fnirt_fout">--fout</a>=filename</tt></dt>
<dd>Name of output-file containing the warp-field itself.</dd>
<dt><tt><a href="#fnirt_jout">--jout</a>=filename</tt></dt>
<dd>Name of output-file containing the Jacobian-field. Useful for diagnosis and VBM.</dd>
<dt><tt><a href="#fnirt_refout">--refout</a>=filename</tt></dt>
<dd>Name of output-file containing the <tt>--ref</tt> image after intensity modulation. Useful for diagnosis.</dd>
<dt><tt><a href="#fnirt_intout">--intout</a>=filename</tt></dt>
<dd>Name of output-file/files containing intensity modulation information.</dd>
</dl>
<br>
<li>Parameters that are are specified "once and for all"</li>
<dl>
<dt><tt><a href="#fnirt_warpres">--warpres</a>=xres,yres,zres</tt></dt>
<dd>Resolution of warps (in mm). <i>E.g.</i> 10,10,10</dd>
<dt><tt><a href="#fnirt_splineorder">--splineorder</a>=n</tt></dt>
<dd>Order of B-spline (2/3).</dd>
<dt><tt><a href="#fnirt_imprefm">--imprefm</a>(=1/0)</tt></dt>
<dd>If set =1 assumes that a certain value in --ref implies outside valid FOV. Set as default.</dd>
<dt><tt><a href="#fnirt_impinm">--impinm</a>(=1/0)</tt></dt>
<dd>If set =1 assumes that a certain value in --in implies outside valid FOV. Set as default.</dd>
<dt><tt><a href="#fnirt_imprefval">--imprefval</a>(=value)</tt></dt>
<dd>If imprefm=1 imprefval specifies what value implies outside valid FOV. Default =0.</dd>
<dt><tt><a href="#fnirt_impinval">--impinval</a>(=value)</tt></dt>
<dd>If impinm=1 impinval specifies what value implies outside valid FOV. Default =0.</dd>
<dt><tt><a href="#fnirt_ssqlambda">--ssqlambda</a>=0/1</tt></dt>
<dd>If set to 1, implies that &lambda should be multiplied by sum-of-squared differences. </dd>
<dt><tt><a href="#fnirt_regmod">--regmod</a>=model</tt></dt>
<dd>Specifies what regularisation-model should be used. <i>E.g.</i> bending_energy</dd>
<dt><tt><a href="#fnirt_refderiv">--refderiv</a></tt></dt>
<dd>If specified implies that derivatives should be calculated from --ref image.</dd>
<dt><tt><a href="#fnirt_intmod">--intmod</a>=model</tt></dt>
<dd>Specifies what intensity-normalisation model should be used.</dd>
<dt><tt><a href="#fnirt_intorder">--intorder</a>=n</tt></dt>
<dd>Specifies the order of polynomial intensity modulation.</dd>
</dl>
<br>
<li>Parameters that are specified once for each sub-sampling level</li>
<dl>
<dt><tt><a href="#fnirt_subsamp">--subsamp</a>=level1,level2,...</tt></dt>
<dd>Levels of sub-sampling for which to perform registration. <i>E.g.</i> 4,2,1</dd>
<dt><tt><a href="#fnirt_miter">--miter</a>=level1,level2,...</tt></dt>
<dd>Number of iterations to run for each level. <i>E.g.</i> 5,5,10</dd>
<dt><tt><a href="#fnirt_reffwhm">--reffwhm</a>=level1,level2,...</tt></dt>
<dd>Amount of smoothing to apply to <tt>--ref</tt> image for each level. <i>E.g.</i> 8,4,0</dd>
<dt><tt><a href="#fnirt_infwhm">--infwhm</a>=level1,level2,...</tt></dt>
<dd>Amount of smoothing to apply to <tt>--in</tt> image for each level. <i>E.g.</i> 10,6,2</dd>
<dt><tt><a href="#fnirt_lambda">--lambda</a>=level1,level2,...</tt></dt>
<dd>Relative weight between sum-of-squared differences and regularisation for each level. <i>E.g.</i> 300,75,30</dd>
<dt><tt><a href="#fnirt_applymask">--estint</a>=level1,level2,...</tt></dt>
<dd>Indicates if the parameters of the intensity model should be estimated or not (1/0). <i>E.g.</i> 1,1,0</dd>
<dt><tt><a href="#fnirt_applymask">--applyrefmask</a>=level1,level2,...</tt></dt>
<dd>Indicates if masking in <tt>--ref</tt>-space should be performed (1/0). <i>E.g.</i> 0,0,1</dd>
<dt><tt><a href="#fnirt_applymask">--applyinmask</a>=level1,level2,...</tt></dt>
<dd>Indicates if masking in <tt>--in</tt>-space should be performed (1/0). <i>E.g.</i> 0,0,1</dd>
</dl>
</ul>

<a name="fnirt_selected_parameters"></a><h3>Selected parameters explained</h3>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_aff"></a><h2><tt>--aff</tt></h2>
<p>
The value for this parameter is typically the name of a text-file obtained from flirt. A typical example would be<br><br>
<tt>flirt -ref MNI152_T1_2mm.nii -in my_brain.nii -omat my_affine_guess.mat</tt><br>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --aff=my_affine_guess.mat ... </tt><br><br>
Fnirt can be quite sensitive to the starting estimate (<i.e.> the value of <tt>--aff</tt>), and if flirt fails, or performs poorly, so will fnirt. It is therefore a good idea to make sure flirt does as well as it can. Flirt is <i>e.g.</i> typically more robust when data has been <a href="../bet/index.html">betted</a> first, whereas fnirt takes un-betted data. The following strategy will therefore often work well<br><br>
<tt>bet my_image.nii my_betted_image.nii</tt><br>
<tt>flirt -ref MNI152_T1_2mm_brain.nii -in my_betted_image.nii -omat my_affine_guess.mat</tt><br>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_image.nii --aff=my_affine_guess.mat ... </tt><br><br>
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_inwarp"></a><h2><tt>--inwarp</tt></h2>
<p>
In the same way as <tt>-aff</tt> provides a &quot;starting guess&quot; for the affine part of the registration the <tt>--inwarp</tt> parmeter provides a &quot;starting guess&quot; for the non-linear part. The value for <tt>--inwarp</tt> can <i>e.g.</i> be a coefficient-file from a previous run of <tt>fnirt</tt>, or it can be a &quot;field-file&quot; generated by some other application. It can be useful <i>e.g.</i> when constructing a population specific template, where at each iteration one can expect that the field should be quite similar to in the previous iteration. By setting <tt>--inwarp</tt> parameter to the field from the previous iteration <tt>fnirt</tt> only has to estimate the incremental difference.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_intin"></a><h2><tt>--intin</tt></h2>
<p>
When providing an initial guess for the non-linear warps (using the <tt>--inwarp</tt> parameter) it is a good idea to provide also an initial guess for the <a href="#fnirt_intensity">intensity mapping</a>. The value of the parameter would then be the name/names of intensity mapping files produced by a previous run of <tt>fnirt</tt>. Depending on which model was used for intensity mapping in the previous run the information may be stored in an ASCII text-file and/or an image file with a bias-field. If specifying only the &quot;basename&quot;, <tt>fnirt</tt> will find the relevant files itself. If <tt>fnirt</tt> was <i>e.g.</i> run with
</p>
<tt>fnirt --ref=...   ... --<a href="#fnirt_intmod">intmod</a>=<a href="#fnirt_global_non_linear_with_bias">global_non_linear_with_bias</a> ... --intout=my_intensity_mapping</tt>
</p>
in the previous run it will have produced two files: <tt>my_intensity_mapping.txt</tt> containing the global mapping and <tt>my_intensity_mapping.nii</tt> containing the bias-field. If then in the next run <tt>fnirt</tt> is passed the parameters 
</p>
<tt>fnirt --ref=...  ... --intin=my_intensity_mapping</tt>
<p>
both <tt>my_intensity_mapping.txt</tt> and <tt>my_intensity_mapping.nii</tt> will be read and used.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_refmask"></a><h2><tt>--refmask</tt></h2>
<p>
Unlike <i>e.g.</i> flirt, fnirt is happiest to work on un-betted data. The reason for this is that even small local failures of <a href="../bet/index.html">bet</a> will create edges that fnirt will try to align. On the other hand we would like to focus our effort on the brain and are quite happy to ignore scalp and other extra cranial tissue. Including extra cranial tissue in the estimation may cause problems for 2 reasons. With a limited resolution of the warps we want to focus on aligning brain structures. Aligning for example the scalp may have a detrimental effect on the alignment of the cortex nearby. Secondly, the intensity in scalp and other extra cranial tissue tend to vary wildly between sequences, much more so than brain tissue. Therefore it may cause problems for the intensity mapping.
</p>
<p>
The solution is to use a (binary) mask in the space of the <tt>--ref</tt> image. The cost-function, its gradient and Hessian is then calculated only for the voxels that fall within the mask. When registering to the MNI152 template it is often a good idea to use the mask supplied with that, <i>e.g.</i> as<br><br>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --refmask=MNI152_T1_2mm_brain_mask_dil.nii ... </tt><br><br>
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_inmask"></a><h2><tt>--inmask</tt></h2>
<p>
Fnirt is rather primitive in its view of the brain. It considers it as a set of intensity values and has no model for different structures, tissue types etc. It would just as happily register a photo of your face to one of your house as two brains together. It is therefore unable to handle cases where a structure (<i>e.g.</i> a tumor or a stroke) is present in one of the images and not the other. However, it may still be of interest to register such a brain into a standard space in order to study effects on structures at some distance from the pathology. Note that this case is distinct from pathologies where existing structures changes its size and/or shape, a case that fnirt can often handle quite well (<a href="#atrophy_brains">see above</a>).
</p>
<p>
It can therefore be useful to supply a mask in the space of the <tt>--in</tt> image. The mask must be binary and is inclusive (i.e. any voxel with a zero value gets excluded). The <tt>--inmask</tt> is warped along with the <tt>--in</tt> image in accordance with the current field. This means that the mask can/will cchange its size and shape as the <tt>--in</tt> image is being warped. Voxels falling outside the mask will be excluded when estimating the warps.
</p>
<p>
An example may make it concrete. Let us say we have a tumor that has an intensity that deviates from the surrounding tissue, and let us say we did not mask it out. Fnirt would then shrink the tumor (and therefore the area with deviation intensities) as much as it can, meanwhile expanding surrounding tissues to "fill the <tt>--ref</tt> brain out". If on the other hand we mask it out the intensity values within the tumor will be ignored and the tumor will be warped in accordance with the surrounding (non-masked) structures.
</p>
<p>
So, let us say you have a an image called <tt>some_brain_with_tumor.nii</tt> that you want to register to the MNI152 template. You may then, <i>e.g.</i> in <a href=../fslview/masking.html>flsview</a>, draw a ROI covering the tumour and save it as <tt>tumor_mask.nii</tt>. You would then run fslmaths as
</p>
<tt>fslmaths tumor_mask -sub 1 -mul -1 tumor_mask</tt>
<p>
which changes the mask so that the tumor is now a "hole of zeros" in a binary image with ones. Finally you would run <tt>fnirt</tt>, excluding the tumor from the calculations, using the command
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=some_brain_with_tumor.nii --inmask=tumor_mask.nii ... </tt><br><br>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_cout"></a><h2><tt>--cout</tt></h2>
<p>
This parameter specifies the name of the main output, a 4D nifti-file containing the spline coefficients and a copy of the affine transform passed as an argument to the <tt>--aff</tt> parameter. Hence it has the full information about the transform and can be passed to <i>e.g.</i> <a href="#fnirt_now_what"><tt>applywarp</tt></a> to warp an image or to <tt>invwarp</tt> to create the inverse of the warp. Most of the <tt>FSL</tt> software has been written such that one can pass either a coefficient-file or file containing the actual warp fields and they will be properly recognised and interpreted. This file is <b>always</b> created even if <tt>--cout</tt> has not been specified. It will then be named after the <tt>--in</tt> volume postfixed by "_warpcoef".
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_iout"></a><h2><tt>--iout</tt></h2>
<p>
This parameter specifies the name of a 3D nifti file containing the <tt>--in</tt> image warped to the space of the <tt>--ref</tt> image. If not specified this file will not be generated. It can always be created "later" using <a href="#fnirt_now_what"><tt>applywarp</tt></a> and the output specified by <tt>--cout</tt>.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_fout"></a><h2><tt>--fout</tt></h2>
<p>
This parameter specifies the name of a 4D nifti file containing the actual warp-fields in the x-, y- and z-directions. If not specified this file will not be generated. It can always be created "later" using <tt>fnirtfileutils</tt> and the output specified by <tt>--cout</tt>.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_jout"></a><h2><tt>--jout</tt></h2>
<p>
This parameter specifies the name of a 3D nifti file where each voxel contains the Jacobian determinant for that location. The Jacobian determinant is a relative measure that relates the volume in the original image to the volume in the warped image. If one <i>e.g.</i> observes a value 0.5 the interpretation is that that structure has been compressed by a factor of 2 from its original size in the <tt>--in</tt> image when warped into the space of the <tt>--ref</tt> image. This is useful when doing VBM where applying the Jacobian map to compensate for expansion/stretching is known as "Jacobian modulation". If not specified this file will not be generated. It can always be created "later" using <tt>fnirtfileutils</tt> and the output specified by <tt>--cout</tt>.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_refout"></a><h2><tt>--refout</tt></h2>
<p>
Specifies the name of a copy of the <tt>--ref</tt> image with intensity modulation applied. This is used mainly as a diagnostic tool for figuring out why/where a given registration went wrong. Not that it ever would.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_intout"></a><h2><tt>--intout</tt></h2>
<p>
Specifies the base-name for file/files containing information about the intensity transform. Depending on what <tt>--intmod</tt> has been set to This can be a text-file containing scaling/polynomial factors, a 3D nifti-file containing a multiplicative bias-field or a 4D nifti-file containing voxel-wise polynomial factors. This is useful mainly for "template building" where one would expect the intensity transform to be very similar from one iteration to the next. One can then generate these files using the <tt>--intout</tt> parameter and then read them in as starting estimates for the next iteration using the <tt>--intin</tt> parameter. 
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_warpres"></a><h2><tt>--warpres</tt></h2>
<p>
Specifies the resolution (in mm) of the warps. In order to <i>e.g.</i> specify an isotropic resolution of 10mm one uses <tt>--warpres=10,10,10</tt>. A warp resolution of <i>e.g.</i> 10mm does <b>not</b> imply that 10mm is the highest accuracy that can be obtained for registration of any given structure. It is rather related to how fast the displacements can change as on goes from one point to the next in the displacement field. An example of a situation where high resolution is useful is when registering an atrophied brain (with enlarged ventricles and an atrophied Putamen) to a "normal" template. One will then need to shrink (compress) the ventricle, and then right next to it one has to expand the Putamen.
</p>
<p>
To increase the resolution comes at no cost in terms of the risk for local minima/silly warps as long as a reasonable shedule of sub-sampling and values for &lambda is specified. It does however mean that <tt>fnirt</tt> needs more memory to run and for standard desk/laptops the practical limit will be ~6-8mm. The warps are implemented as cubic B-splines with a knot-spacing that has to be an integer multiple of the voxel-size of the <tt>--ref</tt> image. If a value is specified for <tt>--warpres</tt> that is not and integer multiple the value will be adjusted down. So if the voxel-size of the <tt>--ref</tt> image is 3x3x4mm and <tt>--warpes</tt> is specified as <tt>--warpres=10,10,10</tt> the actual resolution (knot-spacing) of the warps will be 9x9x8mm.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_splineorder"></a><h2><tt>--splineorder</tt></h2>
<p>
Specifies the order of the B-spline functions modelling the warp-fields. A spline-function is a piecewise continuous polynomial-function and the order of the spline determines the order of the polynomial and the support of the spline. In <tt>fnirt</tt> one can use splines of order 2 (quadratic) or 3 (the "well known" cubic B-spline). A spline of lower order (2 in this case) has a smaller support, <i>i.e.</i> it "covers" fewer voxels, for a given knot-spacing/warp-resolution. This means that the calculation of the hessian matrix <b>H</b> in the minimisation will be faster, and also that <b>H</b> will be sparser and thus use require less memory. That means that going to <tt>--splineorder=2</tt> (compared to the default 3) will allow you to push the resolution of the warps a little further and/or save execution time and memory.
</p>
<p>
The downside with a 2nd order spline is that the resulting field will not have continuous 2nd derivatives which creates some difficulties when using bending energy for regularisation. However, the approximations we are using seem to work so it is not obvious if there really is an issue. We are using <tt>--splineorder=3</tt> as default in <tt>fnirt</tt> because we have more experience with using that. It is not inconcievable that that will change as we gain more experience.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_numprec"></a><h2><tt>--numprec</tt></h2>
<p>
Its value can be either <tt>float</tt> or <tt>double</tt> (default) and it specifies the precision that the hessian <b>H</b> is calculated and stored in. Changing this to <tt>float</tt> will decrease the amount of RAM needed to store <b>H</b> and will hence allow one to go to slightly higher warp-resolution. The default is <tt>double</tt> since that is what we have used for most of the testing and validation. 
</p>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_imprefm"></a><a name="fnirt_impinm"><a name="fnirt_imprefval"></a><a name="fnirt_impinval"></a><h2><tt>--imprefm, --imprefval, --impinm, --impinval</tt></h2>
<p>
When set to 1 the <tt>--imprefm</tt> and <tt>--impinm</tt> flags imply that a certain value implies that that voxel is outside the valid FOV and should be excluded when estimating the warps. This is useful for example if one has data that has already been resampled by an affine transform or if one uses skull stripped data. In both those cases there will be zeros in the image volume that does not mean that the intensity is actually zero, but rather that it is unknown. Note though that the recommended use of <tt>fnirt</tt> is to <i>not</i> use skull-stripped data and to inform <tt>fnirt</tt> of any affine warps through the <a href="#fnirt_aff"><tt>--aff</tt></a> parameter instead of resampling the data. The full form of this parameter is 
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --imprefm=1 ... </tt>
<p>
which specifies that a certain value implies that we are outside the valid FOV. Typically that value will be zero, in which case one does not need to bother with <tt>--imprefval</tt>. Occasionally a software wil use some other value to indicate NaN (I have seen <i>e.g.</i> 1024) and then you can use <tt>--imprefval</tt> to specify that<br><br>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --imprefm=1 --imprefval=1024 ... </tt><br><br>
Both <tt>--imprefm</tt> and <tt>--impinm</tt> are set to 1 as default. So if you know that all the zeros in your images are actuall zero and carry information you need to specify <tt>imprefm=0</tt> and/or <tt>impinm=0</tt>.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_ssqlambda"></a><h2><tt>--ssqlambda</tt></h2>
<p>
The use of several <a href="#fnirt_subsamp">sub-sampling</a> steps (with different values of <a href="#fnirt_lambda">&lambda</a>) helps prevent the registration from venturing into local minima. However, within a given sub-sampling step that regularisation is constant, and that could in turn cause the algorithm to take a "poor" initial step for that resolution level. By weighting &lambda by the current value for the sum-of-squared differences (between the <tt>--ref</tt> image and the warped <tt>--in</tt> image) the effective weight of the regularisation becomes higher for the initial iterations (when we are far from the solution and the sum-of-squares is large). That means that the initial step/steps are a little smoother than they would otherwise be, and hopefully that reduces the risk of finding a local minima.
</p>
<p>
<tt>--ssqlambda</tt> is set to 1 as default, and it is typically a good idea to keep it like that. N.B. that the setting of <tt>--ssqlambda</tt> influences the recommended value/values for <tt>--lambda</tt>. The (average over all voxels) of the sum-of-squared differences is typically in the range 100-1000, and if <tt>--ssqlambda</tt> is set to 0 the value/values for <tt>--lambda</tt> should be adjusted up accordingly.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_regmod"></a><h2><tt>--regmod</tt></h2>
<p>
The value of <tt>--lambda</tt> determines the relative weight <a href="#cost_function_with_regularisation">between the sum-of-squared differences and some function <i>&epsilon</i> of the warps</a>. However, it is not clear what the exact form of that function (<i>&epsilon</i>(<b>w</b>)) should be. We clearly desire "smoothness" in the warps so that points that are close together in the original space ends up (reasonably) close together in the warped space, but there are many potential options for how a particular local warp should be penalised by <i>&epsilon</i>(<b>w</b>). In <tt>fnirt</tt> we have implemented two different choices for <i>&epsilon</i>(<b>w</b>): Membrane Energy (<tt>--regmod=membrane_energy</tt>) or Bending Energy (<tt>--regmod=bending_energy</tt>).
</p>
<p>
The default is to use Bending Energy, and our testing indicate that that is slightly advantageous compared to Membrane Energy.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_refderiv"></a><h2><tt>--refderiv</tt></h2>
<p>
  When this parameter is set the (spatial) derivatives of the <tt>--in</tt> in image is approximated by those of the <tt>--ref</tt> image. Since the <tt>--ref</tt> images remains stationary that means that one does not need to recalculate the gradient and Hessian for each iteration, thereby saving execution time. However, this is only true for the simplest intensity models (<tt>none</tt> and <tt>global_linear</tt>) and is therefore of limited value for most cases.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_intmod"></a><h2><tt>--intmod</tt></h2>
<p>
<tt>intmod</tt> is short for "intensity model" and is the parameter that allows <tt>fnirt</tt> to successfully use a sum-of-squared-differences cost-function even when the assumptions are not completely fulfilled for that. A "theoretical" explanation can be found <a href="#fnirt_intensity">here</a>. The purpose is to model intensity differences between <tt>--ref</tt> and <tt>--in</tt> to avoid these from affecting the estimation of the warps. Modelling the intensity involves estimation of another set of parameters (in addition to those modelling the warps) and will hence increase both execution time and memory requirements. There are six different intensity models. These differ in the kind of differences they can model and also in the number of additional parameters that <tt>fnirt</tt> has to estimate. The models are
</p>
<dl>
<dt><tt>--intmod=none</tt></dt>
<dd>This is in fact no intensity model at all. It simply assumes that the images are identical apart from differences in shape. This is the model one "usually" means when talking about a "sum-of-squared differences cost-function". It is useful mainly for quantitative images such as <i>e.g.</i> FA-images.</dd><br>
<dt><tt>--intmod=global_linear</tt></dt>
<dd>This is the simplest of the actual intensity models. It assumes a linear relationship between the intensities in the two image. It needs to estimate one additional parameter, the slope of the linear relationship. It correponds (roughly) to a traditional correlation-coefficient cost-function. It is useful mainly for registering images acquired with the same scanner and sequence when the images has no or very little intensity inhomogeneity.</dd><br>
<dt><tt>--intmod=global_non_linear</tt></dt>
<dd>This model assumes that there is some curved relationship between the intensities in the two images. Imagine creating a scatter-plot where for each point takes its x-value from a voxel in the <tt>--ref</tt> image and the y-value from the same voxel in the (warped) <tt>--in</tt> image. Let us further assume that this scatter-plot displays a pattern where the majority of the points fall along a curved path. Using this model <tt>fnirt</tt> will fit a polynomial-function to that curve. The order of the polynomial will be determined by the value of the parameter <a href="#fnirt_intorder"><tt>--intorder</tt></a> (and this is also the number of additional parameters that needs to be estimated). It assumes that the curved intensity relationship is the same for all parts of the image (global). It corresponds (roughly) to a correlation-ratio cost-function. It is useful when both images (<tt>--ref</tt> and <tt>--in</tt>) have little or no intensity inhomogeneity and they have been acquired with similar sequences but on different scanners or with <b>slightly</b> different sequences on the same scanner. It could <i>e.g.</i> be used to register two T1-weighted images where the degree of weighting was a little different but would <b>not</b> work for registering a T1- to a T2-weighted image.</dd><br>
<dt><tt>--intmod=local_linear</tt></dt>
<dd>Frequently MR images exhibit RF intensity inhomogeneity, <i>i.e.</i> there is a smoothly varying multiplicative bias-field. This option models such a field as a linear combination of B-splines (same as the warp fields). The properties of the field are determined by the parameters <a href="#fnirt_biasres"><tt>--biasres</tt></a> and <a href="#fnirt_biaslambda"><tt>--biaslambda</tt></a>. The number of additional parameters are also determined by <a href="#fnirt_biasres"><tt>--biasres</tt></a> and is typically substantial (several hundreds -- thousands). This option has no correspondence in traditional cost-functions. It is useful when images are acquired with the same scanner and sequence and there is a discernible bias-field</dd><br> 
<dt><tt>--intmod=global_non_linear_with_bias</tt></dt>
<dd>This model can be said to encompass both previous models (<tt>global_non_linear</tt> and <tt>local_linear</tt>). It models a global curvilinear relationship between the intensities (same as <tt>global_non_linear</tt>) and modulates this locally with a multiplicative factor. The number of additional parameters are given by <tt>--intorder</tt> and <tt>--biasres</tt> and is the sum of the numbers for the two previous models. This means that execution time is roughly twice that of <i>e.g.</i> a <tt>global_linear</tt> model. It is useful when the images are acquired with different scanners and/or slightly different sequences and one or both images have discernible intensity inhomogeneities. This is a suitable model for many cases. One frequently wishes to register an individual image to a template representing some standard space. The subject/subjects constituting the template have typically been scanned elsewhere, and will therefore not have identical contrast. In addition it is very likely that the images will both (or at least ones own) be affected by bias-fields. This is <i>e.g.</i> the model that is used in the <tt>T1_2_MNI152_2mm.cnf</tt> configuration file.</dd><br>
<dt><tt>--intmod=local_non_linear</tt></dt>
<dd>The <tt>local_linear</tt> and <tt>global_non_linear_with_bias</tt> both estimate a single multiplicative bias-field. This model, in contrast, estimates several fields (the number of which is determined by <tt>--intorder</tt>). Let us assume <tt>--intorder=5</tt>. This means that for a given voxel we have five distinct values. These values are used as the coefficients for a local polynomial that models the intensities. This means that, unlike <i>e.g.</i> with a <tt>global_non_linear_with_bias</tt> model, it can model regionally varying contrast. This, we think, can be useful for high-field scanning where spatially varying flip-angles become a significant problem. However, this model has not been properly tested and its use would have to be considered experimental at this time.</dd>
</dl>

<p>
See also <a href="#fnirt_estint"><tt>--estint</tt></a> for an explanation of how it can be useful to allow the intensity modelling to interact with the different subsampling steps.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_intorder"></a><h2><tt>--intorder</tt></h2>
<p>
Determines the order of a polynomial that models a curvilinear relationship between the intensities in the two image. It is relevant for the <tt>global_non_linear</tt>, the <tt>global_non_linear_with_bias</tt> and the <tt>local_non_linear</tt> models. An order of five (default) should be sufficient for most applications.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_biasres"></a><h2><tt>--biasres</tt></h2>
<p>
Determines the knot-spacing for the splines that are used to model a bias-field. It means the same thing as <a href="#fnirt_warpres"><tt>--warpres</tt></a>, but for the bias-field rather than the warp-fields. It is relevant for the <tt>local_linear</tt>, the <tt>global_non_linear_with_bias</tt> and the <tt>local_non_linear</tt> models. Typically a bias-field varies quite slowly over space so a deafult of <tt>--biasres=50,50,50</tt> has been choosen. 
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_biaslambda"></a><h2><tt>--biaslambda</tt></h2>
<p>
Determines the relative weight of the sum-of-squared differences and the bending energy of the bias-field. This is similar to the <tt>--lambda</tt> paramter, but for the bias-field rather than the warp-fields. Default is 10000. 
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_jacrange"></a><h2><tt>--jacrange</tt></h2>
<p>
Specifies the allowable range of Jacobian determinants for the warps (see <a href="#fnirt_diffeomorphic">this</a> for an explanation). The default is <tt>--jacrange=0.01,100</tt>, which is (more or less) equivalent to ensuring diffeomorphism. By setting it to <tt>--jacrange=-1</tt> one allows it to take any values (and to become non-diffeomorphic). For VBM purposes (where the Jacobians are used to modulate the tissue probabilities) it can be advantageous to set a more narrow range (<i>e.g.</i> <tt>--jacrange=0.2,5</tt>) otherwise the presence of very small/large values may lead to highly non-normal (heavy tailed) distributions.
</p>



<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_subsamp"></a><h2><tt>--subsamp</tt></h2>
<p>
As described <a href="#fnirt_subsampling">above</a> a multi-resolution approach consisting of sub-sampling, estimating the warps at currents scale, sample up, estimating the warps at the next scale <i>etc</i> is a way of avoiding local minima. The scheme for this multi resolution approach is given by the <tt>--subsamp</tt> parameter. So for example
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1</tt>
<p>
means that data will be subsampled by a factor of 4 and the transform will be calculated at that level. It will the be subsampled by a factor of 2 (<i>i.e.</i> an upsampling compared to the previous step) and the warps will be estimated at that scale, with the warps from the first scale as a starting estimate. And finally this will be repeated at the full resolution (<i>i.e.</i> subsampling 1).
</p>
<p>
The value of the <tt>--subsampl</tt> parameter will determine the "number of registrations" that are performed as steps in the "total" registration. There are a number of other parameters that can the be set on a "sub-registration" or on a "total registration" basis. So for example
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --reffwhm=8,4,0</tt>
<p>
Means that you order three "sub-registrations" with sub-samplings 4, 2 and 1 respectively <b>and</b> that for the first registration you want the MNI152 template smoothed with an 8mm FWHM Gaussian filter, for the second with a 4mm filter and for the final step no smoothing at all. On the other hand
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --reffwhm=8</tt>
<p>
means that you want the MNI152 smoothed by 8mm for all registration steps. These other parameters must either be specified once, and will then be applied to all sub-registrations, or as many times as there are sub-registraions. The parameters for which this is true are
<ul>
<ul>
<li><a href="#fnirt_miter"><tt>--miter</tt></a></li>
<li><a href="#fnirt_reffwhm"><tt>--reffwhm</tt></a></li>
<li><a href="#fnirt_infwhm"><tt>--infwhm</tt></a></li>
<li><a href="#fnirt_lambda"><tt>--lambda</tt></a></li>
<li><a href="#fnirt_estint"><tt>--estint</tt></a></li>
</ul>
</ul>
<p>
The sub-sampling steps have to be monotonously decreasing, but do not have to be unique. One may for example want to run all steps at the full resolution, but with decreasing amount of regularistaion, as an optional strategy for avoiding local minima. That can be done <i>e.g.</i> with a command like
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=1,1,1 <a href="#fnirt_lambda">--lambda</a>=100,50,25</tt><br><br>

<a href="#fnirt_parameters">Back to list of parameters</a>

<a name="fnirt_miter"></a><h2><tt>--miter</tt></h2>
<p>
Specifies the number of iterations that should be performed for each sub-registration. At present there is no proper convergence criterion implement in fnirt. Instead a fixed number of iterations is used for each step. Each iteration of a Gauss-Newton/Levenberg-Marquardt framework uses a lot of information compared to other optimisation methods such as <i>e.g.</i> steepest descent. That means that converengence is typically very rapid, especially at the cruder sub-sampling steps. Also, it is not critical to run to full convergence at the higher levels since these just serve as starting estimates for the lower levels. Our experience is that after a scheme like
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --miter</a>=5,5,10</tt>
<p>
very little happens to the cost-function. Until a proper test for convergence has been implemented/tested this is something that will have to be determined heuristically.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_reffwhm"></a><a name="fnirt_infwhm"></a><h2><tt>--reffwhm, --infwhm</tt></h2>
<p>
Specifies the amount of smoothing that should be applied to the <tt>--ref</tt> and the <tt>--in</tt> images respectively. It is typically a good idea to match this to the amount of sub-sampling you are using. An example would be the command
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --reffwhm=8,4,0</tt>
<p>
which smoothes the <tt>--ref</tt> image with an 8mm FWHM Gaussian filter prior to subsampling with a factor of 4 for the first level of sub-registration. For the second level it smoothes it by 4mm prior to subsampling by a factor of 2. For the final level it applies no smoothing at all. 
</p>
<p>
Since the MNI152 template is "a little smooth already" owing to its origin as an average of many subjects it is typically a good idea to smooth the <tt>--in</tt> image a little more that the <tt>--ref</tt> image. An example would be
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --reffwhm=8,4,0 --infwhm=10,6,2</tt>
<p>
If you do not specify a value for the <tt>--reffwhm</tt> parameter it will be set to the same value as <tt>--infwhm</tt>. If you do not specify a value for <tt>--infwhm</tt> it will be set to 12,8.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_lambda"></a><h2><tt>--lambda</tt></h2>
<p>
&lambda specifies the relative weighting of the sum-of-squared differences and the regularisation (smoothness) of the warps. A larger value of &lambda implies a smoother warp-field, at the expense of how similar to the <tt>--ref</tt> image that the <tt>--in</tt> image will end up being. There is no principled way to determine the "correct" value and suitable values for &lambda will have to be determined for each "type of data". It will <i>e.g.</i> be the case that a different set of parameters will be used when warping good quality T1-weighted structural images to the MNI152 template compared to when matching (relatively noisy) FA images to the FMRIB58 template. It may also be that if your T1-weighted scans have relatively poor SNR, poor contrast and/or highly non-isotropic voxels you may have to use a different set of &lambda values when matching to the MNI152 template compared to if you have optimal quality data. 
</p>
<p>
You can either specify a single &lambda for all levels of subsampling (<tt><a href="#fnirt_subsamp">--subsamp</a></tt>) or one for each level like
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=4,2,1 --lambda=300,75,30 ...</tt>
<p>
This is usually a good idea and has the advantage of providing over-fitting at the early stage of the registration where the gross features are aligned, while allowing a closer registration at the later stages. This same strategy can be employed even if not utilising the multi-resolution approach by specifying 
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=my_brain.nii --subsamp=1,1,1 --lambda=300,75,30 ...</tt>
<p>
which also prevents over-fitting at the earlier stages. The difference is mainly one of computational efficiency.
</p>
<p>
The specification of &lambda is (sadly) complicated a little by its interaction with the parameters <tt><a href="#fnirt_ssqlambda">--ssqlambda</a></tt> and <tt><a href="#fnirt_regmod">--regmod</a></tt>. Therefore a set of values for &lambda is only "valid" for a specific combination of values for those two parameters. Unless you are a power user who wants to find a set of parameters for a special type of data it is probably easiest to use a pre-determined set from the <a href="#fnirt_examples">examples</a> or using a predefined <a href="#fnirt_config">config file</a>.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_estint"></a><h2><tt>--estint</tt></h2>
<p>
This parameter determines if the parameters of the chosen intesity-model should be estimated or not. This may be useful, and may save time, in conjunction with subsampling schemes. For example in the <tt>T1_2_MNI152_2mm.cnf</tt> configuration file it is used like
</p>
<tt>fnirt ... --subsamp=4,4,2,2,1,1 --lambda=300,150,100,50,40,30 --miter=5,5,5,5,5,10 --estint=1,1,1,1,1,0</tt>
<p>
Here it is assumed that when we get to the final 10 iterations (at the full resolution) the parameters of the intensity model have already been determined with sufficient precision. By therefore leaving them out of those iterations (instead using the parameters that have already been determined) one saves almost 50% of the execution time.
</p>

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_applymask"></a><h2><tt>--applyrefmask, --applyinmask </tt></h2>
<p>
This parameter indicates if the masks specfied with the <tt>--refmask</tt> and <tt>--inmask</tt> parameters should be used or not. You might think "dooh, why else would I have specified them?". The reason is that it is sometimes an advantage to <b>not</b> use the mask for the early iterations. An example could be <i>e.g.</i>
</p>
fnirt ... --ref=MNI152_T1_2mm.nii.gz --refmask=MNI152_T1_2mm_brain_mask_dil.nii.gz --subsamp=4,4,2,2,1,1 --applyrefmask=0,0,0,0,1,1 ...
<p>
where we are <b>not</b> using the brain-mask for the initial (lower resolution) registration steps. This is because the extracranial tissues may give information the improves the robustness of the initial steps. Once one goes to the full resolution one is hopefully quite close to the "true" solution, and then one wants to use the mask to ensure that the registration of the cortical surface is not affected by the scalp. This "trick" can be used when observing that a registration has gone wrong (doesn't look quite right). Sometimes it will work.

<a href="#fnirt_parameters">Back to list of parameters</a><br>

<a name="fnirt_now_what"></a><h3>Now what? -- applywarp!</h3>
<p>
So you have fnirted your images. So you have admired how well they match the template. Now what will you do?
</p>
<p>
You can try using <tt>applywarp</tt> to apply the warps (aptly named, huh?) to some other images. Let us <i>e.g.</i> say that you have some functional data <tt>func.nii</tt> and some structrural data <tt>struct.nii</tt> for the same subject. What you ultimately want is to have your structural data in the MNI152 space, but you realise that there is probably too little structure in the functional scan to drive a non-linear registration. You can then use the following strategy. Start by registering your functional data to the structural scan doing <i>e.g.</i>
</p>
<tt>flirt -ref struct.nii -in func.nii -omat func2struct.mat -dof 6</tt>
</p>
Where the text-file <tt>func2struct.mat</tt> now contains the rigid body transform that maps <tt>func.nii</tt> onto <tt>struct.nii</tt>. The next step is to get an intial affine transform mapping <tt>struct.nii</tt> onto the MNI152 template.
</p>
<tt>bet struct.nii betted_struct.nii<br>
flirt -ref MNI152_T1_2mm_brain.nii -in betted_struct.nii -omat aff_struct2mni.mat</tt>
<p>
Then we use that as initial guess for fnirt
</p>
<tt>fnirt --ref=MNI152_T1_2mm.nii --in=struct.nii --aff=aff_struct2mni.mat ... --cout=warp_struct2mni.nii</tt>
<p>
And then we use that to resample the functional scan into the MNI152 space.
</p>
<tt>applywarp --ref=MNI152_T1_2mm.nii --in=func.nii --out=funcInMNI.nii --coef=warp_struct2mni.nii --premat=func2struct.mat</tt>
<p>
We are now feeding <tt>applywarp</tt> information both about the <tt>struct</tt>->MNI152 mapping and about the <tt>func</tt>-><tt>struct</tt> mapping allowing it to map from <tt>func</tt> to MNI152 in a single step. More information on how to use <tt>applywarp</tt> can be found <a href="./warp_utils.html#applywarp">here</a>

<a name="fnirt_examples"></a><h3>Example uses</h3>

<p>
For the following set of "standard tasks" the commands below are likely to work for you, provided that your data are of reasonable quality.
<dl>
<dt>Registering T1-structural to MNI152</dt>
<tt>bet my_structural my_betted_structural</tt><br>
<tt>flirt -ref ${FSLDIR}/data/standard/MNI152_T1_2mm_brain -in my_betted_structural -omat my_affine_transf.mat</tt><br>
<tt>fnirt --in=my_structural --aff=my_affine_transf.mat --cout=my_nonlinear_transf <a href="#fnirt_config">--config</a>=T1_2_MNI152_2mm</tt><br>
<tt>applywarp --ref=${FSLDIR}/data/standard/MNI152_T1_2mm --in=my_structural --warp=my_nonlinear_transf --out=my_warped_structural</tt><br><br>
<dt>Registering functional data to MNI152 (via structural scan)</dt>
<tt>bet my_structural my_betted_structural</tt><br>
<tt>flirt -ref my_betted_structural -in my_functional -dof 7 -omat func2struct.mat</tt><br>
<tt>flirt -ref ${FSLDIR}/data/standard/MNI152_T1_2mm_brain -in my_betted_structural -omat my_affine_transf.mat</tt><br>
<tt>fnirt --in=my_structural --aff=my_affine_transf.mat --cout=my_nonlinear_transf <a href="#fnirt_config">--config</a>=T1_2_MNI152_2mm</tt><br>
<tt>applywarp --ref=${FSLDIR}/data/standard/MNI152_T1_2mm --in=my_functional --warp=my_nonlinear_transf --premat=func2struct.mat --out=my_warped_functional</tt><br><br>
<dt>Registering FA-image to FMRIB58</dt>
<tt>flirt -ref ${FSLDIR}/data/standard/FMRIB58_FA_1mm_brain -in my_FA -omat my_affine_transf.mat</tt><br>
<tt>fnirt --in=my_FA --aff=my_affine_transf.mat --cout=my_nonlinear_transf <a href="#fnirt_config">--config=</a>FA_2_FMRIB58_1mm</tt><br>
<tt>applywarp --ref=${FSLDIR}/data/standard/FMRIB58_FA_1mm_brain --in=my_FA --warp=my_nonlinear_transf --out=my_warped_FA</tt><br><br>
</dl>
</p>

<hr>
<font SIZE=1>
Copyright &copy; 2007, University of Oxford. <a href="http://www.fmrib.ox.ac.uk/~jesper">Jesper Andersson</a>.
</font>

</body>
</html>
 
